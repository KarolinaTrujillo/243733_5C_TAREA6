# Tarea 6: Lab Reportes: Next.js Reports Dashboard (PostgreSQL + Views + Docker Compose)

## INFORMACI√ìN DEL PROYECTO

- **Materia:** Base de Datos Avanzada
- **Tarea:** 6 - Lab Reportes
- **Estudiante:** Karolina Guadalupe Ram√≠rez Trujillo
- **Matr√≠cula:** 243733
- **Grupo:** 5C
- **Fecha:** 31 de Enero del 2026

## C√ìMO LEVANTAR EL PROYECTO

Para correr todo el proyecto solo necesitas tener Docker instalado y ejecutar este comando en la terminal:

```bash
docker compose up --build
```

Lo que hace este comando es:
- Levanta PostgreSQL con la base de datos
- Crea todas las tablas autom√°ticamente
- Inserta los datos de prueba
- Crea las vistas y los √≠ndices
- Levanta la aplicaci√≥n Next.js en **http://localhost:3000**

Si ya se corri√≥ el proyecto antes y se quiere empezar de cero:

```bash
docker compose down -v
docker compose up --build
```

---

## TECNOLOG√çAS USADAS

### 1. **PostgreSQL 16** 
Es la base de datos. 

### 2. **Next.js 16**
Es el framework de frontend.

### 3. **Docker & Docker Compose**
Docker permite empaquetar todo el proyecto (base de datos + aplicaci√≥n) en contenedores. As√≠ no se tiene que instalar PostgreSQL manualmente ni configurar nada complicado. Con Docker Compose, se levanta todo con un solo comando.

### 4. **Node.js 20**
Es el runtime que usa Next.js para ejecutarse.

---

## ESTRUCTURA DEL PROYECTO

```
üì¶ 243733_5C_TAREA6
‚îú‚îÄ‚îÄ üìÇ tarea6/
‚îÇ   ‚îî‚îÄ‚îÄ üìÇ db/                    # Scripts de base de datos
‚îÇ       ‚îú‚îÄ‚îÄ schema.sql            # Definici√≥n de tablas
‚îÇ       ‚îú‚îÄ‚îÄ seed.sql              # Datos de prueba
‚îÇ       ‚îú‚îÄ‚îÄ migrate.sql           # Migraciones
‚îÇ       ‚îú‚îÄ‚îÄ reports_vw.sql        # Vistas de reportes
‚îÇ       ‚îú‚îÄ‚îÄ indexes.sql           # √çndices para optimizaci√≥n
‚îÇ       ‚îî‚îÄ‚îÄ roles.sql             # Roles y permisos
‚îÇ
‚îú‚îÄ‚îÄ üìÇ tarea6-karo/               # Aplicaci√≥n Next.js
‚îÇ   ‚îú‚îÄ‚îÄ üìÇ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÇ app/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ üìÇ reports/       # P√°ginas de reportes
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 1/            # Reporte 1: Ventas por categor√≠a
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 2/            # Reporte 2: Productos m√°s vendidos
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 3/            # Reporte 3: Resumen de usuarios
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 4/            # Reporte 4: Ranking de productos
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 5/            # Reporte 5: Ventas por orden
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx          # P√°gina principal
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ üìÇ lib/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ db.ts             # Conexi√≥n a la base de datos
‚îÇ   ‚îî‚îÄ‚îÄ dockerfile                # Configuraci√≥n del contenedor
‚îÇ
‚îú‚îÄ‚îÄ docker-compose.yml            # Orquestaci√≥n de servicios
‚îî‚îÄ‚îÄ README.MD                     # Este archivo 
```

**¬øC√≥mo funciona?**
1. Los archivos en `tarea6/db/` se ejecutan autom√°ticamente cuando se levanta PostgreSQL
2. Primero crea las tablas (`schema.sql`)
3. Luego inserta datos de prueba (`seed.sql`)
4. Despu√©s crea las vistas para reportes (`reports_vw.sql`)
5. Finalmente crea los √≠ndices para optimizar (`indexes.sql`)
6. La aplicaci√≥n Next.js se conecta a la base de datos y muestra los reportes

---

## ¬øQU√â SON LAS VISTAS (VIEWS)?

Las vistas son como consultas SQL guardadas. En lugar de escribir consultas largas cada vez que se quiere ver un reporte, se crea una vista y solo se hace `SELECT * FROM nombre_vista`.

**Las 5 vistas:**
1. `vw_ventas_por_categoria` - Cu√°nto se vendi√≥ de cada categor√≠a
2. `vw_productos_mas_vendidos` - Qu√© productos se venden m√°s
3. `vw_resumen_usuarios` - Cu√°ntas √≥rdenes y cu√°nto gast√≥ cada usuario
4. `vw_ranking_productos` - Ranking de productos por ventas
5. `vw_ventas_por_orden` - Total de cada orden

---

## ¬øPOR QU√â SE NECESITAN LOS √çNDICES?

las vistas usan `JOIN` (unir tablas) y `GROUP BY` (agrupar datos), y sin √≠ndices, PostgreSQL tiene que revisar **TODAS** las filas de las tablas, lo cual es super lento.

Los √≠ndices son como el √≠ndice de un libro. En lugar de leer todo el libro para encontrar un tema, se va al √≠ndice y dice en qu√© p√°gina est√°. As√≠ funcionan los √≠ndices en las bases de datos.

---

## √çNDICES CREADOS (An√°lisis Detallado)

### 1. `idx_productos_categoria_id`

**Definici√≥n:**
```sql
CREATE INDEX idx_productos_categoria_id
ON productos (categoria_id);
```

**¬øPara qu√© sirve?**

Este √≠ndice es clave para la vista `vw_ventas_por_categoria`. Cuando la vista hace el JOIN entre `productos` y `categorias`, sin este √≠ndice PostgreSQL tendr√≠a que buscar la categor√≠a de cada producto revisando toda la tabla. Con el √≠ndice, va directo a los productos de cada categor√≠a.

**Ejemplo pr√°ctico:**
- Sin √≠ndice: "Busca todos los productos y ve cu√°l pertenece a la categor√≠a 1" (lento)
- Con √≠ndice: "Dame todos los productos con `categoria_id = 1`" (r√°pido)

**Operaciones que optimiza:**
- **JOIN entre productos y categor√≠as**: El √≠ndice permite encontrar r√°pidamente todos los productos de una categor√≠a espec√≠fica
- **GROUP BY categor√≠a**: Al agrupar por categor√≠a, el √≠ndice ya tiene los datos organizados, as√≠ que es m√°s eficiente
- **Filtros WHERE**: Si alg√∫n d√≠a queremos filtrar por categor√≠a, el √≠ndice lo hace instant√°neo

**Vista que lo usa:** `vw_ventas_por_categoria`

---

### 2. `idx_ordenes_usuario_id`

**Definici√≥n:**
```sql
CREATE INDEX idx_ordenes_usuario_id
ON ordenes (usuario_id);
```

**¬øPara qu√© sirve?**

Este √≠ndice es fundamental para `vw_resumen_usuarios`. Cuando queremos saber cu√°ntas √≥rdenes tiene cada usuario y cu√°nto ha gastado, necesitamos encontrar todas las √≥rdenes de cada usuario r√°pidamente.

**Ejemplo pr√°ctico:**
- Sin √≠ndice: Revisa las 1000 √≥rdenes una por una para ver cu√°les son del usuario 2 (s√∫per lento)
- Con √≠ndice: "Dame todas las √≥rdenes donde `usuario_id = 2`" (instant√°neo)

**Operaciones que optimiza:**
- **JOIN entre ordenes y usuarios**: Encuentra todas las √≥rdenes de un usuario espec√≠fico sin revisar toda la tabla
- **GROUP BY usuario**: Agrupa las √≥rdenes por usuario de forma eficiente
- **COUNT() y SUM()**: Al contar √≥rdenes o sumar totales por usuario, el √≠ndice acelera el acceso a los datos
- **An√°lisis por cliente**: Facilita identificar clientes frecuentes vs ocasionales

**Vista que lo usa:** `vw_resumen_usuarios`

---

### 3. `idx_orden_detalles_orden_id`

**Definici√≥n:**
```sql
CREATE INDEX idx_orden_detalles_orden_id
ON orden_detalles (orden_id);
```

**¬øPara qu√© sirve?**

Este √≠ndice es esencial cuando queremos ver los detalles de cada orden. Cada orden puede tener m√∫ltiples productos (detalles), y necesitamos encontrarlos r√°pido para calcular el total de la orden.

**Ejemplo pr√°ctico:**
Suponiendo que una orden tiene 10 productos diferentes:
- Sin √≠ndice: Busca en toda la tabla `orden_detalles` (que puede tener miles de registros) para encontrar esos 10 productos
- Con √≠ndice: Va directo a los 10 detalles de esa orden

**Operaciones que optimiza:**
- **JOIN entre ordenes y orden_detalles**: Encuentra todos los productos de una orden espec√≠fica instant√°neamente
- **GROUP BY orden**: Agrupa los detalles por orden para calcular totales
- **SUM() de subtotales**: Suma r√°pidamente el total de cada orden
- **An√°lisis de composici√≥n de √≥rdenes**: Facilita ver qu√© productos tiene cada orden

**Vista que lo usa:** `vw_ventas_por_orden` y `vw_resumen_usuarios`

---

### 4. `idx_orden_detalles_producto_id`

**Definici√≥n:**
```sql
CREATE INDEX idx_orden_detalles_producto_id
ON orden_detalles (producto_id);
```

**¬øPara qu√© sirve?**

Este es uno de los √≠ndices m√°s importantes porque se usa en varias vistas. Ayuda a saber qu√© tan bien se vende cada producto, cu√°ntas veces se ha comprado y en qu√© √≥rdenes aparece.

**Ejemplo pr√°ctico:**
Se quiere saber cu√°ntas veces se vendi√≥ el "iPhone 15":
- Sin √≠ndice: Revisa cada detalle de orden uno por uno (si hay 5000 detalles, revisa los 5000)
- Con √≠ndice: "Dame todos los detalles donde el producto es iPhone 15" (encuentra solo los relevantes)

**Operaciones que optimiza:**
- **JOIN entre orden_detalles y productos**: Encuentra todas las ventas de un producto espec√≠fico
- **GROUP BY producto**: Agrupa las ventas por producto para saber cu√°les son m√°s populares
- **SUM(cantidad)**: Suma cu√°ntas unidades se vendieron de cada producto
- **HAVING con filtros**: Filtra productos con m√°s de X ventas de forma eficiente
- **An√°lisis de popularidad**: Identifica productos estrella y productos de baja rotaci√≥n

**Vistas que lo usan:** `vw_productos_mas_vendidos`, `vw_ranking_productos`, y `vw_ventas_por_categoria`

---

### 5. `idx_productos_id_nombre`

**Definici√≥n:**
```sql
CREATE INDEX idx_productos_id_nombre
ON productos (id, nombre);
```

**¬øPara qu√© sirve?**

Este es un **√≠ndice compuesto** (tiene dos columnas). Es especial porque optimiza tanto el agrupamiento como el ordenamiento de productos. Se usa espec√≠ficamente para el ranking de productos donde se necesita el ID y el nombre juntos.

**¬øPor qu√© compuesto?**
Porque en la vista `vw_ranking_productos` hacemos `GROUP BY p.id, p.nombre`. PostgreSQL puede usar este √≠ndice para acceder a ambas columnas a la vez, en lugar de hacer dos b√∫squedas separadas.

**Ejemplo pr√°ctico:**
- Sin √≠ndice: Busca el ID, luego busca el nombre, luego ordena todo (tres operaciones)
- Con √≠ndice compuesto: Tiene el ID y nombre ya juntos y ordenados (una operaci√≥n)

**Operaciones que optimiza:**
- **GROUP BY con m√∫ltiples columnas**: Agrupa por ID y nombre simult√°neamente
- **ORDER BY**: Si ordenamos por producto, el √≠ndice ya tiene los datos ordenados
- **SELECT de ambas columnas**: Acceso r√°pido a ID y nombre juntos
- **Funciones de ventana (RANK, ROW_NUMBER)**: Optimiza el c√°lculo de rankings
- **Operaciones de sorting**: Reduce el tiempo de ordenamiento significativamente

**Vista que lo usa:** `vw_ranking_productos`

---

## ¬øQU√â ES EXPLAIN?

`EXPLAIN` es una herramienta s√∫per √∫til que nos dice **c√≥mo** PostgreSQL va a ejecutar una consulta. Es como pedirle a la base de datos que nos cuente su plan antes de hacerlo.

Muestra el "plan de ejecuci√≥n" que PostgreSQL va a usar, pero **NO ejecuta** la consulta.

```sql
EXPLAIN
SELECT * FROM vw_ventas_por_categoria;
```

**¬øQu√© te muestra?**
- Qu√© tipo de escaneo va a hacer (Seq Scan, Index Scan, etc.)
- Qu√© √≠ndices va a usar
- En qu√© orden va a hacer los JOINs
- Estimaci√≥n de cu√°ntas filas va a revisar
- Costo estimado de la operaci√≥n

**Tipos de escaneo que puedes ver:**
- **Seq Scan**: Escaneo secuencial (lee toda la tabla) - MALO üê¢
- **Index Scan**: Usa un √≠ndice espec√≠fico - BUENO üöÄ
- **Bitmap Index Scan**: Usa m√∫ltiples √≠ndices - BUENO üöÄ
- **Hash Join**: Uni√≥n usando hash - NEUTRAL
- **Nested Loop**: Bucle anidado para JOIN - Depende del contexto

**Ejemplo de salida:**
```
Hash Join  (cost=1.36..2.51 rows=11 width=426)
  Hash Cond: (od.producto_id = p.id)
  ->  Seq Scan on orden_detalles od  (cost=0.00..1.11 rows=11 width=8)
  ->  Hash  (cost=1.16..1.16 rows=16 width=422)
        ->  Index Scan using idx_productos_id_nombre on productos p  (cost=0.00..1.16 rows=16 width=422)
```

**¬øQu√© significa esto?**
- `cost=1.36..2.51`: Costo estimado (menor es mejor)
- `rows=11`: Cu√°ntas filas estima que va a procesar
- `width=426`: Tama√±o promedio de cada fila en bytes
- `Index Scan using idx_productos_id_nombre`: Est√° planeando usar el √≠ndice

### **Verificaci√≥n de nuestros √≠ndices**

En el archivo `indexes.sql` ya incluimos los comandos para verificar que los √≠ndices se est√©n usando:

```sql
-- Verifica si se usa idx_productos_categoria_id
EXPLAIN
SELECT * FROM vw_ventas_por_categoria;

-- Verifica si se usa idx_orden_detalles_producto_id
EXPLAIN
SELECT * FROM vw_productos_mas_vendidos;

-- Verifica si se usa idx_ordenes_usuario_id
EXPLAIN
SELECT * FROM vw_resumen_usuarios;
```

**¬øQu√© buscamos en la salida?**
- "Index Scan using idx_..." = El √≠ndice se va a usar (BIEN)
- "Seq Scan on ..." = NO va a usar √≠ndice (MAL, hay que revisar)

---

## RESUMEN R√ÅPIDO

**El proyecto tiene:**
- 5 tablas principales (categorias, usuarios, productos, ordenes, orden_detalles)
- 5 vistas de reportes (para analizar ventas, usuarios y productos)
- 5 √≠ndices estrat√©gicos (para hacer las consultas s√∫per r√°pidas)

**Para correrlo:**
```bash
docker compose up --build
```

**Para verificar los √≠ndices:**
Con√©ctarse a PostgreSQL y ejecutar los comandos EXPLAIN que est√°n en `indexes.sql`

**Tecnolog√≠as:**
- PostgreSQL 16 (base de datos)
- Next.js 16 (frontend)
- Docker (contenedores)

---

## üéì CONCLUSI√ìN

Los √≠ndices son como agregar un mapa a tu base de datos. Sin ellos, PostgreSQL tiene que buscar todo de forma secuencial (lento). Con ellos, va directo a lo que necesita (r√°pido). 

En este proyecto, identificamos las operaciones m√°s comunes (JOINs y GROUP BYs en las vistas) y creamos √≠ndices espec√≠ficos para optimizarlas. El resultado es que las consultas se ejecutan en milisegundos en lugar de segundos.
