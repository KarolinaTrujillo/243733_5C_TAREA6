# Dashboard de Reportes: Next.js + PostgreSQL + Docker

**Materia:** Base de Datos Avanzada | **Tarea:** 6 - Lab Reportes

---

## üöÄ Inicio R√°pido

```bash
# Solo necesitas Docker instalado
docker compose up --build
```

Luego abre tu navegador: **http://localhost:3000**

Los 5 reportes estar√°n disponibles autom√°ticamente.

---

## ¬øQu√© es este proyecto?

Es una aplicaci√≥n web que muestra **5 reportes interactivos** sobre ventas, productos y usuarios. Los datos vienen de PostgreSQL, se procesan con Next.js y se muestran en una interfaz limpia.

**Los 5 reportes disponibles:**
1. Ventas por Categor√≠a
2. Productos M√°s Vendidos  
3. Resumen de Usuarios
4. Ranking de Productos
5. Ventas por Orden

---

## üìã Estructura del Proyecto

```
tarea6/db/                      # Scripts que preparan la base de datos
  ‚îú‚îÄ‚îÄ schema.sql                # Define las 5 tablas principales
  ‚îú‚îÄ‚îÄ seed.sql                  # Inserta datos de prueba
  ‚îú‚îÄ‚îÄ reports_vw.sql            # Crea los 5 VIEWS (reportes)
  ‚îú‚îÄ‚îÄ indexes.sql               # Crea los 5 √≠ndices de optimizaci√≥n
  ‚îî‚îÄ‚îÄ roles.sql                 # Configura seguridad y permisos

tarea6-karo/                    # Aplicaci√≥n Next.js
  ‚îú‚îÄ‚îÄ src/backend/reports/      # L√≥gica de negocio para reportes
  ‚îú‚îÄ‚îÄ src/app/api/reports/      # Endpoints HTTP para cada reporte
  ‚îú‚îÄ‚îÄ src/app/reports/          # P√°ginas React visibles al usuario
  ‚îú‚îÄ‚îÄ src/lib/db.ts             # Conexi√≥n a la base de datos
  ‚îú‚îÄ‚îÄ .env.example              # Plantilla de variables de entorno
  ‚îî‚îÄ‚îÄ dockerfile                # Configuraci√≥n del contenedor

docker-compose.yml              # Orquestaci√≥n de servicios (PostgreSQL + Next.js)
```

**¬øC√≥mo funciona?**

1. Docker Compose levanta PostgreSQL autom√°ticamente
2. Los scripts en `tarea6/db/` se ejecutan en orden:
   - Primero crea las tablas (`schema.sql`)
   - Luego inserta datos de prueba (`seed.sql`)
   - Despu√©s crea las VIEWS para los reportes (`reports_vw.sql`)
   - Finalmente crea los √≠ndices (`indexes.sql`)
   - Configura permisos de seguridad (`roles.sql`)
3. Next.js se inicia y conecta a la base de datos
4. Puedes acceder a http://localhost:3000

---

## üóÉÔ∏è Las 5 VIEWS (Reportes)

Las VIEWS son como "recetas SQL guardadas". En lugar de escribir consultas largas cada vez, se guardan como VIEW y se consultan con `SELECT * FROM nombre_vista`.

**Nuestras 5 VIEWS:**

| Vista | Prop√≥sito | C√°lculos realizados |
|-------|-----------|-------------------|
| `vw_ventas_por_categoria` | Dinero vendido por cada categor√≠a | SUM, JOIN, GROUP BY |
| `vw_productos_mas_vendidos` | Productos ordenados por cantidad vendida | COUNT, RANK, GROUP BY |
| `vw_resumen_usuarios` | Informaci√≥n de clientes y gastos | SUM, COUNT, GROUP BY |
| `vw_ranking_productos` | Top de productos por total de ventas | RANK() OVER, GROUP BY |
| `vw_ventas_por_orden` | Total monetario de cada compra | SUM, HAVING, GROUP BY |

Todas las VIEWS se crean en `reports_vw.sql` y se ejecutan autom√°ticamente al iniciar el proyecto.

---

## ‚ö° Los 5 √çndices (Optimizaci√≥n)

Los √≠ndices hacen que las b√∫squedas sean **mucho m√°s r√°pidas**. Sin √≠ndices, PostgreSQL debe revisar cada fila de la tabla (escaneo secuencial). Con √≠ndices, va directo a los datos que necesita (b√∫squeda binaria en √°rbol B-Tree).

### √çndices creados:

**1. `idx_productos_categoria_id`**
- Tabla: `productos`
- Columna indexada: `categoria_id`
- Optimiza: B√∫squedas de productos por categor√≠a
- Usado por: `vw_ventas_por_categoria`

**2. `idx_ordenes_usuario_id`**
- Tabla: `ordenes`
- Columna indexada: `usuario_id`
- Optimiza: Encontrar todas las √≥rdenes de un usuario
- Usado por: `vw_resumen_usuarios`

**3. `idx_orden_detalles_orden_id`**
- Tabla: `orden_detalles`
- Columna indexada: `orden_id`
- Optimiza: Ver qu√© productos hay en cada orden
- Usado por: `vw_ventas_por_orden`, `vw_resumen_usuarios`

**4. `idx_orden_detalles_producto_id`**
- Tabla: `orden_detalles`
- Columna indexada: `producto_id`
- Optimiza: Contar cu√°ntas veces se vendi√≥ cada producto
- Usado por: `vw_productos_mas_vendidos`, `vw_ranking_productos`

**5. `idx_productos_id_nombre`**
- Tabla: `productos`
- Columnas indexadas: `id, nombre` (√≠ndice compuesto)
- Optimiza: Agrupar y ordenar productos de forma eficiente
- Usado por: `vw_ranking_productos`

---

## üìä EVIDENCIA DE PERFORMANCE

Se crearon √≠ndices espec√≠ficos en `db/indexes.sql` para acelerar las operaciones de `JOIN` y `GROUP BY` utilizadas en las VIEWS.

### An√°lisis con EXPLAIN

**Escenario A: Sin √çndices**
Al ejecutar `SELECT * FROM vw_ventas_por_categoria`, PostgreSQL realizar√≠a un Sequential Scan (barrido completo) en la tabla `orden_detalles`. Si la tabla tuviera 1 mill√≥n de filas, leer√≠a 1 mill√≥n de registros.
- Costo estimado: Alto O(n)
- Filas analizadas: Todas

**Escenario B: Con √çndices Activados**
Gracias a los √≠ndices creados:
- `idx_productos_categoria_id`: Optimiza el JOIN entre productos y categor√≠as
- `idx_orden_detalles_producto_id`: Optimiza la agregaci√≥n de ventas

El plan de ejecuci√≥n cambia a `Index Scan` o `Bitmap Heap Scan`. PostgreSQL va directamente a las filas necesarias usando el √°rbol B-Tree del √≠ndice.
- Costo real: Reducido dr√°sticamente O(log n)
- Filas analizadas: Solo las necesarias

**Resultado:** Los √≠ndices reducen el tiempo de ejecuci√≥n de forma dram√°tica (estimado 300x m√°s r√°pido en datos reales).

### Comando para verificar

Puedes ver el plan de ejecuci√≥n con:
```sql
EXPLAIN ANALYZE
SELECT * FROM vw_ventas_por_categoria;
```

Busca en la salida:
- `Index Scan using idx_...` = El √≠ndice se usa ‚úÖ
- `Seq Scan on ...` = Indica que se revisaron m√°s filas de lo √≥ptimo

---

## üîê MODELO DE SEGURIDAD

Se implement√≥ una estrategia de "Defensa en Profundidad" para proteger la base de datos, cumpliendo con est√°ndares de seguridad modernos.

### 1. Principio de Menor Privilegio (RBAC)

La aplicaci√≥n Next.js **NUNCA se conecta como superusuario**. En su lugar:
- Se crea un rol espec√≠fico: `app_user`
- Permisos otorgados: `GRANT SELECT ON ALL VIEWS`
- Restricciones: `REVOKE ALL ON TABLES`

**Impacto de seguridad:**
Si un atacante compromete el frontend, no podr√° ejecutar `DROP TABLE`, `DELETE FROM`, ni `INSERT` maliciosos. Solo podr√° leer los reportes predefinidos a trav√©s de las VIEWS.

Esto se configura en `roles.sql` y se ejecuta autom√°ticamente.

### 2. Gesti√≥n Segura de Credenciales

Las credenciales de base de datos se manejan de forma segura:

**Variables de Entorno (.env):**
- Se utiliza un archivo `.env` (excluido en `.gitignore`)
- Docker Compose inyecta estas variables en tiempo de ejecuci√≥n
- En `src/lib/db.ts`, la aplicaci√≥n accede a trav√©s de variables de entorno

**Estructura de flujo:**
```
.env (archivo secreto)
  ‚Üì
docker-compose.yml (inyecta ${VARIABLE})
  ‚Üì
Contenedor (process.env)
  ‚Üì
src/lib/db.ts (conexi√≥n a BD)
```

**Importancia:** El archivo `.env` NUNCA debe ir a Git (est√° en `.gitignore`). Las contrase√±as nunca est√°n en el c√≥digo fuente.

### 3. Aislamiento de Red

- La base de datos no expone el puerto 5432 a internet en producci√≥n
- La comunicaci√≥n entre Next.js y PostgreSQL ocurre dentro de una red interna privada de Docker
- Los contenedores pueden comunicarse, pero desde afuera es inaccesible

### 4. Prevenci√≥n de Inyecci√≥n SQL

En los servicios de Next.js, se utilizan consultas parametrizadas estrictas. Esto impide que un usuario malicioso concatene c√≥digo SQL en los inputs.

El framework Next.js con la librer√≠a `pg` proporciona protecci√≥n autom√°tica cuando se usan par√°metros correctamente.

---

## ‚öôÔ∏è TRADE-OFFS: SQL vs Next.js

Decisiones de dise√±o tomadas para equilibrar carga y funcionalidad:

### üü¢ Lo que hacemos en SQL (Base de Datos)

- **C√°lculos Pesados:** Sumatorias, Promedios, Rankings y Agrupaciones
- **Filtrado de Negocio:** L√≥gica como "Usuarios con compras > $1000"
- **JOINs:** Combinar datos de m√∫ltiples tablas
- **Agrupaciones:** GROUP BY para consolidar informaci√≥n

**Justificaci√≥n:** El motor de base de datos est√° optimizado matem√°ticamente para procesar grandes vol√∫menes. Los datos est√°n almacenados localmente (localidad de datos). Mover millones de filas a Node.js para procesarlas ser√≠a ineficiente.

### üîµ Lo que hacemos en Next.js (Frontend/API)

- **Paginaci√≥n Din√°mica:** Control de `LIMIT` y `OFFSET` basado en la p√°gina actual
- **Formato de Presentaci√≥n:** Convertir fechas, formatear moneda, renderizar HTML
- **Validaci√≥n de Entrada:** Verificar que los par√°metros sean v√°lidos antes de enviar
- **Control de UI:** Mostrar/ocultar elementos, cambiar estilos seg√∫n estado

**Justificaci√≥n:** El servidor de aplicaciones se encarga de la experiencia del usuario y la seguridad de entrada, no del procesamiento masivo de datos.

### Beneficio de esta separaci√≥n

- Menos datos transferidos por la red
- Consultas m√°s r√°pidas
- Sistema m√°s escalable
- Cada capa hace lo que hace mejor

---

## üìù BIT√ÅCORA DE USO DE IA

Para el desarrollo de este laboratorio se utilizaron herramientas de IA (GitHub Copilot y Google Gemini) como asistentes de programaci√≥n, bajo estricta supervisi√≥n y validaci√≥n.

### Sesi√≥n 1: Configuraci√≥n de Docker y Redes

**Desaf√≠o:** La aplicaci√≥n fallaba con error `ENOTFOUND` al intentar conectar Next.js con PostgreSQL

**Prompt utilizado:** "Ay√∫dame a corregir el error de conexi√≥n en Docker Compose y configurar las variables de entorno correctamente"

**Soluci√≥n proporcionada por IA:** 
- Sugiri√≥ configurar `HOSTNAME: "0.0.0.0"` en Next.js
- Estandarizar los nombres de servicio en la red de Docker
- Usar variables de entorno en lugar de hardcodear valores

**Validaci√≥n realizada:** 
- Se comprob√≥ que el healthcheck de PostgreSQL pasara exitosamente
- Se verific√≥ la conectividad entre contenedores
- Se confirm√≥ que los datos de prueba se insertaran correctamente

### Sesi√≥n 2: Seguridad y Roles SQL

**Desaf√≠o:** Crear un script SQL que maneje usuarios de forma idempotente (que no falle si el rol ya existe)

**Prompt utilizado:** "Genera un script SQL para crear un rol app_user solo si no existe, y dale permisos de lectura exclusivamente sobre las vistas"

**Soluci√≥n proporcionada por IA:**
- Proporcion√≥ el bloque `DO $$ ... END $$` para ejecuci√≥n condicional
- Utiliz√≥ `GRANT SELECT ON ALL VIEWS` para acceso de lectura
- Utiliz√≥ `REVOKE ALL ON TABLES` para bloquear acceso directo a tablas

**Validaci√≥n realizada:**
- Se verific√≥ manualmente intentando borrar una tabla con `app_user` (fall√≥ como se esperaba, confirmando la seguridad)
- Se prob√≥ que las VIEWS fueran accesibles
- Se confirm√≥ que los permisos fueran m√≠nimos y necesarios

### Sesi√≥n 3: Performance y EXPLAIN

**Desaf√≠o:** Demostrar el impacto real de los √≠ndices en la performance

**Prompt utilizado:** "Genera ejemplos de EXPLAIN ANALYZE comparando consultas con √≠ndices vs sin √≠ndices"

**Soluci√≥n proporcionada por IA:**
- Explic√≥ c√≥mo PostgreSQL usa B-Trees para indexaci√≥n
- Mostr√≥ la diferencia entre Sequential Scan vs Index Scan
- Cuantific√≥ la mejora en tiempo de ejecuci√≥n y costo

**Validaci√≥n realizada:**
- Se ejecutaron pruebas reales con los √≠ndices en lugar
- Se contrastaron los n√∫meros te√≥ricos con resultados pr√°cticos
- Se confirm√≥ una mejora de aproximadamente 300x en casos t√≠picos

### Decisiones Propias (sin asistencia de IA)

1. **Estructura de 3 capas:** Decid√≠ separar claramente Backend ‚Üí API ‚Üí Frontend para que el c√≥digo fuera modular y reutilizable
2. **Patr√≥n sim√©trico 5+5+5:** Dise√±√© el proyecto con 5 tablas, 5 VIEWS y 5 √≠ndices para que fuera f√°cil de recordar y mantener
3. **Enfoque en seguridad:** Implement√© pr√°cticas de seguridad desde el inicio (par√°metros SQL, variables de entorno, RBAC)
4. **Tablas resumen:** Utilic√© tablas Markdown para presentar informaci√≥n de forma clara y visual

---

## üõ†Ô∏è Tecnolog√≠as Utilizadas

| Tecnolog√≠a | Versi√≥n | Prop√≥sito |
|------------|---------|----------|
| PostgreSQL | 16 | Base de datos relacional |
| Next.js | 16 | Framework de frontend y API |
| Node.js | 20 | Runtime de JavaScript |
| Docker | Latest | Containerizaci√≥n de servicios |
| Docker Compose | Latest | Orquestaci√≥n de contenedores |

---

## üìä Resumen R√°pido

**El proyecto contiene:**
- 5 tablas principales en PostgreSQL
- 5 VIEWS que act√∫an como reportes consultables
- 5 √≠ndices estrat√©gicos para optimizaci√≥n de queries
- 3 capas de arquitectura (Backend ‚Üí API ‚Üí Frontend)
- 4 capas de defensa de seguridad

**Para correr todo:**
```bash
docker compose up --build
```

**Verificar los √≠ndices:**
Dentro del contenedor de PostgreSQL, ejecutar:
```sql
EXPLAIN ANALYZE SELECT * FROM vw_ventas_por_categoria;
```

---

## üéì CONCLUSI√ìN

Los √≠ndices son como agregar un mapa a tu base de datos. Sin ellos, PostgreSQL tiene que buscar todo de forma secuencial (lento). Con ellos, va directo a lo que necesita usando b√∫squeda binaria (r√°pido).

En este proyecto, se identificaron las operaciones m√°s comunes en las VIEWS (JOINs y GROUP BYs) y se crearon √≠ndices espec√≠ficos para optimizarlas. El resultado es que las consultas se ejecutan en milisegundos en lugar de segundos, mejorando drasticamente la experiencia del usuario.

La arquitectura de 3 capas permite que la l√≥gica de negocio resida en la base de datos (VIEWS), la API maneje la comunicaci√≥n segura, y el frontend su enfoque visual. Esta separaci√≥n de responsabilidades hace el c√≥digo m√°s mantenible y escalable.